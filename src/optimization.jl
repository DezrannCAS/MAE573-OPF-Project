# TODO: 
# - Update the DCOPF to smt closer to Notebook version
# - write the stochastic version using train_data generated by generate_batches()
# - Find heuristic methods
# - Implement the heuristic methods


module Optimization

using JuMP, HiGHS

export build_dcopf, solve_model


"""
    build_dcopf(data::Dict)

Builds and returns a DC Optimal Power Flow (DCOPF) model using the input `data`.
"""
function build_dcopf(data::Dict)
    # Extract datasets from the input dictionary
    bus = data["bus"]
    branch = data["branch"]
    plant = data["plant"]
    load = data["load"]
    gencost = data["gencost"]

    # Map bus IDs to indices
    bus_id_map = Dict(sort(unique(bus.bus_id)) .=> 1:length(unique(bus.bus_id)))

    # Define sets
    G = sort(plant.plant_id)                                                  # Indices of power plants (several per bus)
    D = sort([bus_id_map[parse(Int, name)] for name in names(load)[3:end]])   # Indices of demand nodes
    N = sort(bus.idx)                                                         # Indices of all buses
    L = sort(branch.branch_id)                                                # Indices of all branches
    T = 1:size(load, 1)                                                       # Time indices

    @assert length(G) == length(unique(plant.plant_id))
    @assert length(N) == length(unique(bus.idx)) && length(N) >= length(D)
    @assert length(L) == length(unique(branch.branch_id))
    @assert first(G) == first(D) == first(N) == first(L) == 1

    # Create the DCOPF model
    DCOPF = Model(HiGHS.Optimizer)

    # Define variables
    @variables(DCOPF, begin
        GEN[G, T]                          # Generator output
        THETA[N, T]                        # Voltage phase angle at each bus
        FLOW[L, T]                         # Power flow on each branch
    end)

    # Slack bus constraint: fix reference angle at the first bus
    slack_bus = N[1]
    @constraint(DCOPF, cSlack[t in T], THETA[slack_bus, t] == 0)

    # Generator limits
    pmin = Dict(plant.plant_id .=> plant.pmin)
    pmax = Dict(plant.plant_id .=> plant.pmax)
    @constraint(DCOPF, cGenLimits[g in G, t in T], pmin[g] <= GEN[g, t] <= pmax[g])

    # Ramping constraints (limits are divided by 2 for hourly ramp)
    ramp_limit = Dict(plant.plant_id .=> plant.ramp_30 / 2)
    @constraint(DCOPF, cGenMax[g in G, t in T[2:end]], GEN[g, t] - GEN[g, t-1] <= ramp_limit[g])
    @constraint(DCOPF, cGenMin[g in G, t in T[2:end]], GEN[g, t-1] - GEN[g, t] <= ramp_limit[g])

    # Power balance constraint
    #demand = Dict(D .=> [load[t, 3:end] for t in T])
    demand = Dict(n => (n in D ? [load[t, string(bus[bus.idx .== n, :bus_id][1])] for t in T] : zeros(length(T))) for n in N)
        # demand mapping: net power at each at each bus should either equal demand is bus in D or zero
    start_bus = Dict(branch.branch_id .=> branch.start_idx)
    end_bus = Dict(branch.branch_id .=> branch.end_idx)
    @constraint(DCOPF, cBalance[n in N, t in T],
        sum(FLOW[l, t] for l in L if start_bus[l] == n) - 
        sum(FLOW[l, t] for l in L if end_bus[l] == n) + 
        sum(GEN[g, t] for g in G if plant.bus_idx[g] == n) == demand[n][t])

    # Power flow constraints on lines (set x very large to virtually close a line)
    x = Dict(branch.branch_id .=> branch.x)
    @constraint(DCOPF, cLineFlow[l in L, t in T],
        FLOW[l, t] == (THETA[start_bus[l], t] - THETA[end_bus[l], t]) / x[l])  # SHOULD WE ADD baseMVA ???
    
    # Objective function: minimize generation cost
    costs = Dict(gencost.plant_id .=> zip(gencost.c2, gencost.c1, gencost.c0))
    @objective(DCOPF, Min, 
    sum(sum(costs[g][1] * GEN[g,t]^2 +
            costs[g][2] * GEN[g,t] +
            costs[g][3]
            for t in T)
        for g in G))
    
    return DCOPF
end


"""
    build_stochastic_dcopf(data::Dict, scenarios::Vector{Dict}, probs::Vector{Float64})

Builds and returns a stochastic DC Optimal Power Flow (DCOPF) model using the input `data`, a set of `scenarios`,
and their associated probabilities `probs`.
"""
function build_stochastic_dcopf(data::Dict, scenarios::Vector{Dict}, probs::Vector{Float64})
    # Validate input
    @assert length(scenarios) == length(probs) "Each scenario must have an associated probability."
    @assert sum(probs) â‰ˆ 1.0 "Probabilities must sum to 1."

    # Extract common data
    bus = data["bus"]
    plant = data["plant"]
    gencost = data["gencost"]

    # Define sets
    G = plant.id                 # Generator IDs
    N = bus.bus_i                # Bus (node) IDs
    S = 1:length(scenarios)      # Scenario indices

    # Base MVA value
    baseMVA = 100.0

    # Create the optimization model
    StochDCOPF = Model(HiGHS.Optimizer)

    # Define scenario-specific variables and constraints
    @variables(StochDCOPF, begin
        GEN[g in G, s in S] >= 0  # Generator outputs per scenario
        THETA[n in N, s in S]    # Voltage angle at each bus per scenario
    end)

    # Fix reference bus angle to 0 for all scenarios
    for s in S
        fix(THETA[1, s], 0)
    end

    # Objective function: Minimize expected generation costs across scenarios
    @objective(StochDCOPF, Min,
        sum(probs[s] * sum(gencost[g, :x1] * GEN[g, s] for g in G) for s in S)
    )

    # Add scenario-specific constraints
    for s in S
        scenario = scenarios[s]
        scenario_branch = scenario["branch"]
        scenario_load = scenario["load"]

        # Power balance constraints
        @constraint(StochDCOPF, [i in N],
            sum(GEN[g, s] for g in plant[plant.bus .== i, :id]) - 
            sum(scenario_load[scenario_load.bus .== i, :demand]) == 
            sum(scenario_branch[scenario_branch.fbus .== i, :sus] .* 
                (THETA[i, s] - THETA[scenario_branch[scenario_branch.fbus .== i, :tbus]]))
        )

        # Generation capacity constraints
        @constraint(StochDCOPF, [g in G], GEN[g, s] <= plant[plant.id .== g, :pmax][1])

        # Line flow constraints
        @constraint(StochDCOPF, [k in 1:size(scenario_branch, 1)],
            scenario_branch[k, :sus] * baseMVA * 
            (THETA[scenario_branch[k, :fbus], s] - THETA[scenario_branch[k, :tbus], s]) <= scenario_branch[k, :ratea]
        )
    end

    return StochDCOPF
end



"""
    solve_model(model::Model)

Solves the optimization model and returns the results as a named tuple with:
    - generation: DataFrame of generator outputs
    - angles: Vector of voltage angles
    - flows: DataFrame of transmission line flows
    - prices: DataFrame of marginal prices at each bus
    - cost: Optimal generation cost
    - status: Solver termination status
"""
function solve_model(DCOPF::Model, data::Dict)
    bus = data["bus"]
    branch = data["branch"]
    plant = data["plant"]

    N = sort(unique(bus.bus_id))

    # Solve the model
    optimize!(DCOPF)

    # Output results
    generation = DataFrame(
        bus = plant.bus_id,
        generation = value.(GEN)
    )

    angles = value.(THETA)

    flows = DataFrame(
        from_bus = branch.start_bus,
        to_bus = branch.end_bus,
        flow = [value(FLOW[f, t]) for (f, t) in zip(branch.start_bus, branch.end_bus)]
    )

    prices = DataFrame(
        bus = N,
        price = dual.(cBalance)
    )

    return (
        generation = generation,
        angles = angles,
        flows = flows,
        prices = prices,
        cost = objective_value(DCOPF),
        status = termination_status(DCOPF)
    )
end


end
