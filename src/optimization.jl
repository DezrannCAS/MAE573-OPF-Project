# TODO: 
# - write the stochastic version using train_data generated by generate_batches()
# - Find heuristic methods
# - Implement the heuristic methods


module DCOPF

using JuMP, Gurobi, DataFrames, Statistics  # not HiGHS

export perform_optimization


"""
    perform_dcopf(data::Dict)

Builds and returns a DC Optimal Power Flow (DCOPF) model using the input `data`.
"""
function perform_optimization(data::Dict)
    # Extract datasets from the input dictionary
    bus = data["bus"]
    branch = data["branch"]
    plant = data["plant"]
    load = data["load"]
    gencost = data["gencost"]

    @assert all(branch.x .> 0) "All `branch.x` values must be positive (line reactances)"
    @assert all(branch.x .> 0) "All `branch.x` values must be positive (line reactances)"
    @assert all(plant.pmin .<= plant.pmax) "For all plants, `pmin` must be <= `pmax`"
    @assert all(plant.ramp_30 .>= 0) "All `plant.ramp_30` values must be non-negative"
    @assert all(x -> all(x .>= 0), eachcol(load[:, 3:end])) "All `load` values must be non-negative"
    @assert all(gencost[!, :c2] .>= 0) "Quadratic cost coefficients `c2` must be non-negative"
    @assert all(gencost[!, :c1] .>= 0) "Linear cost coefficients `c1` must be non-negative"
    @assert all(gencost[!, :c0] .>= 0) "Constant cost coefficients `c0` must be non-negative"
    @assert all(x -> !ismissing(x), plant.pmin) "Some rows in `plant` have missing 'pmin' values"
    @assert all(x -> !ismissing(x), plant.pmax) "Some rows in `plant` have missing 'pmax' values"    
    @assert all(.!isnan.(plant.pmin)) "Some rows in `plant` have NaN in 'pmin'"
    @assert all(.!isnan.(plant.pmax)) "Some rows in `plant` have NaN in 'pmax'"    
                

    # Map bus IDs to indices
    bus_id_map = Dict(sort(unique(bus.bus_id)) .=> 1:length(unique(bus.bus_id)))

    # Define sets
    G = sort(plant.plant_id)                                                  # Indices of power plants (several per bus)
    D = sort([bus_id_map[parse(Int, name)] for name in names(load)[3:end]])   # Indices of demand nodes
    N = sort(bus.idx)                                                         # Indices of all buses
    L = sort(branch.branch_id)                                                # Indices of all branches
    T = 1:size(load, 1)                                                       # Time indices

    @assert length(G) == length(unique(plant.plant_id))
    @assert length(N) == length(unique(bus.idx)) && length(N) >= length(D)
    @assert length(L) == length(unique(branch.branch_id))
    # @assert first(G) == first(D) == first(N) == first(L) == 1

    # Create the DCOPF model
    #DCOPF = Model(HiGHS.Optimizer)
    DCOPF = Model(Gurobi.Optimizer)

    # Define variables
    @variables(DCOPF, begin
        GEN[G, T]                          # Generator output
        THETA[N, T]                        # Voltage phase angle at each bus
        FLOW[L, T]                         # Power flow on each branch
    end)

    # Slack bus constraint: fix reference angle at the first bus
    slack_bus = N[1]
    @constraint(DCOPF, cSlack[t in T], THETA[slack_bus, t] == 0)

    # Generator limits
    pmin = Dict(plant.plant_id .=> plant.pmin)
    pmax = Dict(plant.plant_id .=> plant.pmax)
    @constraint(DCOPF, cGenLimits[g in G, t in T], pmin[g] <= GEN[g, t] <= pmax[g])

    # Ramping constraints (limits are divided by 2 for hourly ramp)
    ramp_limit = Dict(plant.plant_id .=> plant.ramp_30 / 2)
    @constraint(DCOPF, cGenMax[g in G, t in T[2:end]], GEN[g, t] - GEN[g, t-1] <= ramp_limit[g])
    @constraint(DCOPF, cGenMin[g in G, t in T[2:end]], GEN[g, t-1] - GEN[g, t] <= ramp_limit[g])

    # Power balance constraint
    #demand = Dict(D .=> [load[t, 3:end] for t in T])
    demand = Dict(n => (n in D ? [load[t, string(bus[bus.idx .== n, :bus_id][1])] for t in T] : zeros(length(T))) for n in N)
        # demand mapping: net power at each at each bus should either equal demand is bus in D or zero
    start_bus = Dict(branch.branch_id .=> branch.start_idx)
    end_bus = Dict(branch.branch_id .=> branch.end_idx)
    @constraint(DCOPF, cBalance[n in N, t in T],
        sum(FLOW[l, t] for l in L if start_bus[l] == n) - 
        sum(FLOW[l, t] for l in L if end_bus[l] == n) + 
        sum(GEN[g, t] for g in G if plant.bus_idx[g] == n) == demand[n][t])

    # Power flow constraints on lines (set x very large to virtually close a line)
    x = Dict(branch.branch_id .=> branch.x)
    @constraint(DCOPF, cLineFlow[l in L, t in T],
        FLOW[l, t] == (THETA[start_bus[l], t] - THETA[end_bus[l], t]) / x[l])  # SHOULD WE ADD baseMVA ???
    
    # Objective function: minimize generation cost
    costs = Dict(gencost.plant_id .=> zip(gencost.c2, gencost.c1, gencost.c0))
    # @objective(DCOPF, Min, 
    # sum(sum(costs[g][1] * GEN[g,t]^2 +  # Exclude quadratic terms with HiGHS!
    #         costs[g][2] * GEN[g,t] +
    #         costs[g][3]
    #         for t in T)
    #     for g in G))
    @objective(DCOPF, Min,
    sum(sum(costs[g][2] * GEN[g,t] for t in T)
        for g in G))

    optimize!(DCOPF)
    
    # Check solver status
    status = termination_status(DCOPF)
    if status != MOI.OPTIMAL
        println("Model did not solve to optimality. Status: $status")
        return status
    else
        println("Model solved to optimality.")
    end

    # Retrieve outputs
    generation = Dict((g, t) => value(GEN[g, t]) for g in G, t in T)
    angles = Dict((n, t) => value(THETA[n, t]) for n in N, t in T)
    flows = Dict((l, t) => value(FLOW[l, t]) for l in L, t in T)
    prices = Dict(n => shadow_price(cBalance[n, t]) for n in N, t in T)

    generation = DataFrame(
        plant = G,
        total_generation = [sum(value(GEN[g, t]) for t in T) for g in G]
    )

    angles = DataFrame(
        bus = N,
        average_angle = [mean(value(THETA[n, t]) for t in T) for n in N]
    )

    flows = DataFrame(
        branch = L,
        total_flow = [sum(value(FLOW[l, t]) for t in T) for l in L]
    )

    prices = DataFrame(
        bus = N,
        average_price = [mean(dual.(cBalance[n, t]) for t in T) for n in N]
    )

    return (
        generation = generation,
        angles = angles,
        flows = flows,
        prices = prices,
        cost = objective_value(DCOPF),
        status = status
    )
end

end